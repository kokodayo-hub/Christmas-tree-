<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>3D Christmas Hands</title>
    <style>
        /* åŸºç¡€æ ·å¼é€‚é… */
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Helvetica Neue', sans-serif; touch-action: none; /* ç¦æ­¢é»˜è®¤è§¦æ‘¸è¡Œä¸º */ }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        /* UI å±‚é€‚é…ç§»åŠ¨ç«¯ */
        #ui {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            color: #d4af37; pointer-events: none;
            width: 90%;
        }
        h1 { margin: 0; font-size: 24px; font-weight: 200; letter-spacing: 1px; text-shadow: 0 0 10px rgba(212, 175, 55, 0.5); }
        .status { font-size: 16px; font-weight: bold; margin-top: 5px; opacity: 0.9; }
        .instruction { font-size: 12px; color: #aaa; margin-top: 10px; line-height: 1.4; background: rgba(0,0,0,0.3); padding: 5px; border-radius: 5px; }
        
        /* äº¤äº’æŒ‰é’® */
        #uploader {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); z-index: 20;
            pointer-events: auto; width: 80%; text-align: center;
        }
        input[type="file"] { display: none; }
        .btn {
            display: inline-block; width: 100%;
            background: rgba(20, 40, 30, 0.9); border: 1px solid #d4af37; color: #d4af37;
            padding: 12px 0; border-radius: 20px;
            cursor: pointer; text-transform: uppercase; letter-spacing: 1px; font-size: 14px; font-weight: bold;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }

        /* è§†é¢‘å…ƒç´ å¿…é¡»å­˜åœ¨ä½†éšè— */
        #input_video { 
            position: absolute; top: 0; left: 0; width: 1px; height: 1px; opacity: 0; pointer-events: none; 
            /* å…³é”®å±æ€§ï¼šé˜²æ­¢æ‰‹æœºå…¨å±æ’­æ”¾ */
            transform: scaleX(-1); 
        }
        
        /* åŠ è½½åŠ¨ç”» */
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100; display: flex; justify-content: center; align-items: center;
            color: #d4af37; flex-direction: column; transition: opacity 0.5s; text-align: center; padding: 20px;
        }
    </style>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loader">
        <div style="font-size: 18px; margin-bottom: 20px;">æ­£åœ¨å¯åŠ¨ 3D å¼•æ“...</div>
        <div style="font-size: 14px; color: #888;">è¯·åœ¨å¼¹å‡ºçš„çª—å£ä¸­å…è®¸ä½¿ç”¨æ‘„åƒå¤´<br>å»ºè®®å°†æ‰‹æœºå›ºå®šæ”¾ç½®</div>
    </div>

    <div id="ui">
        <h1>åœ£è¯ç²’å­æ ‘</h1>
        <div class="status" id="status-text">çŠ¶æ€: ç­‰å¾…æ‰‹åŠ¿...</div>
        <div class="instruction">
            âœŠ æ¡æ‹³: èšåˆæˆæ ‘ | ğŸ– å¼ å¼€: ç‚¸å¼€ç²’å­<br>
            ğŸ‘Œ æåˆ: æŸ¥çœ‹ç…§ç‰‡ | ğŸ‘‹ æŒ¥æ‰‹: æ—‹è½¬è§†è§’
        </div>
    </div>

    <div id="uploader">
        <label class="btn">
            ä¸Šä¼ ç›¸å†Œç…§ç‰‡
            <input type="file" id="photo-input" multiple accept="image/*">
        </label>
    </div>

    <div id="canvas-container"></div>
    
    <video id="input_video" playsinline webkit-playsinline muted autoplay></video>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- é…ç½® ---
        const CONFIG = {
            colors: { green: 0x2F4F4F, gold: 0xFFD700, red: 0x8B0000 },
            // æ‰‹æœºç«¯å‡å°‘ç²’å­æ•°é‡ä»¥ä¿è¯æµç•…åº¦
            particleCount: 800, 
            photoCount: 8, 
            treeHeight: 50,
            treeRadius: 20
        };

        const STATE = {
            mode: 'TREE',
            handDetected: false,
            focusedPhotoIndex: -1,
            rotationSpeed: { x: 0, y: 0 }
        };

        let scene, camera, renderer, composer;
        let instances = []; 
        let photos = []; 
        let dummy = new THREE.Object3D();
        
        function init() {
            const container = document.getElementById('canvas-container');

            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.003); // åŠ é‡é›¾æ°”é®æŒ¡è¿œå¤„ç‘•ç–µ

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 500); // å¹¿è§’æ›´å¤§ï¼Œé€‚åˆæ‰‹æœºç«–å±
            camera.position.set(0, 10, 90);

            // æ¸²æŸ“å™¨ä¼˜åŒ–
            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            // é™åˆ¶åƒç´ æ¯”ï¼Œé˜²æ­¢é«˜åˆ†å±æ‰‹æœºå‘çƒ­
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); 
            renderer.toneMapping = THREE.ReinhardToneMapping;
            container.appendChild(renderer.domElement);

            // åå¤„ç† (é™ä½åˆ†è¾¨ç‡ä»¥æé€Ÿ)
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth/2, window.innerHeight/2), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0;
            bloomPass.strength = 1.0; 
            bloomPass.radius = 0.5;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // ç¯å…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(CONFIG.colors.gold, 2, 200);
            pointLight.position.set(0, 40, 20);
            scene.add(pointLight);

            createParticles();
            createPhotoPlaceholders();

            window.addEventListener('resize', onWindowResize);
            document.getElementById('photo-input').addEventListener('change', handlePhotoUpload);
            
            animate();
        }

        // --- ç‰©ä½“åˆ›å»ºé€»è¾‘ (ä¸ä¹‹å‰ç›¸åŒï¼Œç•¥å¾®è°ƒæ•´å‚æ•°) ---
        function createParticles() {
            const sphereGeo = new THREE.SphereGeometry(0.7, 8, 8); // é™ä½å‡ ä½•ç²¾åº¦
            const boxGeo = new THREE.BoxGeometry(1.0, 1.0, 1.0);
            
            const material = new THREE.MeshStandardMaterial({
                color: 0xffffff, roughness: 0.3, metalness: 0.7,
            });

            const sphereMesh = new THREE.InstancedMesh(sphereGeo, material, CONFIG.particleCount);
            const boxMesh = new THREE.InstancedMesh(boxGeo, material, CONFIG.particleCount / 2);

            fillInstancedMesh(sphereMesh, CONFIG.colors.gold, CONFIG.colors.red);
            fillInstancedMesh(boxMesh, CONFIG.colors.green, CONFIG.colors.gold);

            scene.add(sphereMesh);
            scene.add(boxMesh);
            instances.push(sphereMesh, boxMesh);
        }

        function fillInstancedMesh(mesh, color1, color2) {
            const count = mesh.count;
            const color = new THREE.Color();
            mesh.userData = { velocities: [], targetPositions: [], currentPositions: [], homePositions: [] };

            for (let i = 0; i < count; i++) {
                const x = (Math.random() - 0.5) * 150;
                const y = (Math.random() - 0.5) * 150;
                const z = (Math.random() - 0.5) * 150;
                
                dummy.position.set(x, y, z);
                dummy.updateMatrix();
                mesh.setMatrixAt(i, dummy.matrix);

                color.setHex(Math.random() > 0.5 ? color1 : color2);
                mesh.setColorAt(i, color);

                mesh.userData.currentPositions.push(new THREE.Vector3(x, y, z));
                mesh.userData.velocities.push(new THREE.Vector3(0,0,0));
                
                // æ ‘å½¢è®¡ç®—
                const angle = i * 0.15 + Math.random(); 
                const heightRatio = i / count; 
                const r = (1 - heightRatio) * CONFIG.treeRadius;
                const h = (heightRatio * CONFIG.treeHeight) - (CONFIG.treeHeight/2);
                
                const tx = Math.cos(angle * 8) * r;
                const tz = Math.sin(angle * 8) * r;
                
                mesh.userData.homePositions.push(new THREE.Vector3(tx, h, tz));
                mesh.userData.targetPositions.push(new THREE.Vector3(tx, h, tz));
            }
        }

        function createPhotoPlaceholders() {
            const geo = new THREE.PlaneGeometry(8, 10); // ç«–å±ç…§ç‰‡æ›´å¥½çœ‹
            for(let i=0; i<CONFIG.photoCount; i++) {
                const canvas = document.createElement('canvas');
                canvas.width = 200; canvas.height = 250;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#222'; ctx.fillRect(0,0,200,250);
                ctx.strokeStyle = '#d4af37'; ctx.lineWidth = 8; ctx.strokeRect(4,4,192,242);
                ctx.fillStyle = '#fff'; ctx.font = '30px Arial'; ctx.textAlign='center';
                ctx.fillText('ç…§ç‰‡', 100, 125);
                
                const tex = new THREE.CanvasTexture(canvas);
                const mat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide });
                const mesh = new THREE.Mesh(geo, mat);
                
                const angle = (i / CONFIG.photoCount) * Math.PI * 2;
                const r = CONFIG.treeRadius + 8;
                const h = ((i / CONFIG.photoCount) * CONFIG.treeHeight) - (CONFIG.treeHeight/2);
                
                mesh.userData = {
                    homePos: new THREE.Vector3(Math.cos(angle)*r, h, Math.sin(angle)*r),
                    currentPos: new THREE.Vector3((Math.random()-0.5)*100, (Math.random()-0.5)*100, 0),
                    targetPos: new THREE.Vector3(0,0,0)
                };
                mesh.position.copy(mesh.userData.currentPos);
                scene.add(mesh);
                photos.push(mesh);
            }
        }

        function handlePhotoUpload(e) {
            const files = e.target.files;
            if(!files.length) return;
            let fileIndex = 0;
            for(let i=0; i<photos.length; i++) {
                if (fileIndex >= files.length) fileIndex = 0;
                const reader = new FileReader();
                const photoMesh = photos[i];
                reader.onload = (event) => {
                    const img = new Image();
                    img.src = event.target.result;
                    img.onload = () => {
                        const tex = new THREE.Texture(img);
                        tex.needsUpdate = true;
                        tex.colorSpace = THREE.SRGBColorSpace;
                        // è‡ªåŠ¨è°ƒæ•´UVé˜²æ­¢æ‹‰ä¼¸ç•¥å¤æ‚ï¼Œè¿™é‡Œç®€å•å¡«å……
                        photoMesh.material.map = tex;
                        photoMesh.material.needsUpdate = true;
                    }
                };
                reader.readAsDataURL(files[fileIndex]);
                fileIndex++;
            }
        }

        // --- æ ¸å¿ƒåŠ¨ç”»å¾ªç¯ ---
        function updateTargets() {
            const time = performance.now() * 0.001;
            instances.forEach(mesh => {
                const count = mesh.count;
                for(let i=0; i<count; i++) {
                    const home = mesh.userData.homePositions[i];
                    let target = mesh.userData.targetPositions[i];
                    
                    if (STATE.mode === 'TREE') {
                        target.copy(home);
                    } else {
                        // ç‚¸å¼€æ•ˆæœ
                        const noiseX = Math.sin(time + i) * 20;
                        const noiseY = Math.cos(time * 0.8 + i) * 20;
                        const noiseZ = Math.sin(time * 0.5 + i) * 20;
                        target.set(home.x * 2.5 + noiseX, home.y * 2.5 + noiseY, home.z * 2.5 + noiseZ);
                    }
                }
            });

            photos.forEach((photo, i) => {
                if (STATE.mode === 'FOCUS' && i === STATE.focusedPhotoIndex) {
                    const camDir = new THREE.Vector3();
                    camera.getWorldDirection(camDir);
                    // æ‰‹æœºå±å¹•å°ï¼Œç…§ç‰‡æ‹‰å¾—æ›´è¿‘ä¸€ç‚¹
                    const targetPos = new THREE.Vector3().copy(camera.position).add(camDir.multiplyScalar(15));
                    photo.userData.targetPos.copy(targetPos);
                    photo.lookAt(camera.position);
                } else if (STATE.mode === 'TREE') {
                    photo.userData.targetPos.copy(photo.userData.homePos);
                    photo.lookAt(0, photo.position.y, 0);
                } else {
                     photo.userData.targetPos.set(photo.userData.homePos.x * 3, photo.userData.homePos.y * 3, photo.userData.homePos.z * 3);
                }
            });
        }

        function animateObjects() {
            const lerpSpeed = 0.06;
            instances.forEach(mesh => {
                for(let i=0; i<mesh.count; i++) {
                    const current = mesh.userData.currentPositions[i];
                    const target = mesh.userData.targetPositions[i];
                    current.lerp(target, lerpSpeed);
                    dummy.position.copy(current);
                    dummy.rotation.set(dummy.position.x, dummy.position.y, 0); // ç®€å•è‡ªè½¬
                    dummy.updateMatrix();
                    mesh.setMatrixAt(i, dummy.matrix);
                }
                mesh.instanceMatrix.needsUpdate = true;
            });
            photos.forEach(photo => photo.position.lerp(photo.userData.targetPos, lerpSpeed));
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            updateTargets();
            animateObjects();

            // è‡ªåŠ¨æ—‹è½¬ + æ‰‹åŠ¿è¾…åŠ©æ—‹è½¬
            if (STATE.mode === 'SCATTER' || STATE.mode === 'TREE') {
                 scene.rotation.y += 0.002; // æ…¢é€Ÿè‡ªè½¬å±•ç¤º
                 if(STATE.handDetected) {
                     scene.rotation.y += STATE.rotationSpeed.x * 0.02;
                     scene.rotation.x += STATE.rotationSpeed.y * 0.01;
                 }
            }
            composer.render();
        }

        // --- MediaPipe é€‚é…æ‰‹æœºé€»è¾‘ ---
        const videoElement = document.getElementById('input_video');
        const statusText = document.getElementById('status-text');

        function onResults(results) {
            document.getElementById('loader').style.display = 'none';

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                STATE.handDetected = true;
                const landmarks = results.multiHandLandmarks[0];
                
                // 1. åˆ¤æ–­æ‰‹åŠ¿
                const tips = [8, 12, 16, 20];
                const wrist = landmarks[0];
                let extendedFingers = 0;
                tips.forEach(tipIndex => {
                    // æ‰‹æœºä¸ŠZè½´æ›´é‡è¦ï¼Œä½¿ç”¨ç®€å•Yè½´è·ç¦»åˆ¤æ–­ï¼ˆæ‰‹å¿ƒæœå‘å±å¹•ï¼‰
                    if (landmarks[tipIndex].y < landmarks[tipIndex - 2].y) extendedFingers++;
                });

                // 2. æåˆåˆ¤æ–­
                const pinchDist = Math.hypot(landmarks[4].x - landmarks[8].x, landmarks[4].y - landmarks[8].y);
                const isPinch = pinchDist < 0.05;

                // 3. æ—‹è½¬æ˜ å°„ (åè½¬Xè½´ä»¥è·å¾—é•œåƒæ„Ÿ)
                STATE.rotationSpeed.x = -(landmarks[9].x - 0.5) * 3; 
                STATE.rotationSpeed.y = (landmarks[9].y - 0.5) * 3;

                // çŠ¶æ€æœº
                if (isPinch) {
                    if (STATE.mode !== 'FOCUS') {
                        STATE.mode = 'FOCUS';
                        STATE.focusedPhotoIndex = (STATE.focusedPhotoIndex + 1) % CONFIG.photoCount; // é™åˆ¶ç´¢å¼•
                        statusText.innerText = "çŠ¶æ€: ç…§ç‰‡å›å¿† (æåˆ)";
                        statusText.style.color = "#ff3333";
                    }
                } else if (extendedFingers <= 1) {
                    STATE.mode = 'TREE';
                    statusText.innerText = "çŠ¶æ€: åœ£è¯æ ‘ (æ¡æ‹³)";
                    statusText.style.color = "#00ff00";
                } else if (extendedFingers >= 4) {
                    STATE.mode = 'SCATTER';
                    statusText.innerText = "çŠ¶æ€: æ¼«å¤©ç¹æ˜Ÿ (å¼ å¼€)";
                    statusText.style.color = "#00ffff";
                }
            } else {
                STATE.handDetected = false;
                // statusText.innerText = "çŠ¶æ€: æœªæ£€æµ‹åˆ°æ‰‹"; ä¿æŒæœ€åçŠ¶æ€é¿å…é—ªçƒ
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});
        
        // æ‰‹æœºç«¯æ¨¡å‹å¤æ‚åº¦è°ƒä½ï¼Œä¿è¯é€Ÿåº¦
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 0, // 0 = Lite (æœ€å¿«), 1 = Full
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        
        hands.onResults(onResults);

        // æ‰‹æœºæ‘„åƒå¤´å¯åŠ¨é€»è¾‘
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 480, // é™ä½å¤„ç†åˆ†è¾¨ç‡
            height: 640,
            facingMode: 'user' // å¼ºåˆ¶å‰ç½®æ‘„åƒå¤´
        });
        
        // é”™è¯¯å¤„ç†
        try {
            init();
            cameraUtils.start().catch(err => {
                alert("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥: " + err + "\nè¯·ç¡®ä¿åœ¨HTTPSç¯å¢ƒä¸‹è¿è¡Œï¼Œå¹¶å…è®¸æ‘„åƒå¤´æƒé™ã€‚");
            });
        } catch (e) {
            alert("WebGLåˆå§‹åŒ–å¤±è´¥ï¼Œæ‚¨çš„æ‰‹æœºå¯èƒ½ä¸æ”¯æŒã€‚");
        }

    </script>
</body>
</html>
